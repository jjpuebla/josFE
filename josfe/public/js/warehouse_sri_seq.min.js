// SRI Puntos Emisi√≥n ‚Äî Warehouse client script (Frappe v15)
// -----------------------------------------------------------------------------
// Features:
// ‚Ä¢ INIT/EDIT dialog for the six sequentials with validation.
// ‚Ä¢ Blocks Save until every row is INIT'd (all six seq >= 1).
// ‚Ä¢ Server RPC resolves/creates rows by (Warehouse + emission_point_code).
// ‚Ä¢ Tooltips, read-only grid cols, prevents auto-save edits.
// ‚Ä¢ 3-digit guards for: establishment code (parent) and emission point (child).
//
// Notes:
// ‚Ä¢ No attempts to hide the inline "pencil" (row open icon) are included.
// ‚Ä¢ All event bindings are namespaced and idempotent to survive grid refreshes.
// -----------------------------------------------------------------------------

(() => {
  const CHILD = 'SRI Puntos Emision';
  const WAREHOUSE = 'Warehouse';

  // Put your exact child table fieldname first; others are fallbacks
  const TABLEFIELDS = [
    'custom_jos_SRI_puntos_emision',
    'custom_jos_Sri_puntos_emision',
    'custom_sri_puntos_emision'
  ];

  // Map child seq fields -> server doc-type labels (must match FIELD_BY_TYPE in state.py)
  const DOC_BY_FIELD = {
    seq_factura: 'Factura',
    seq_nc: 'Nota de Cr√©dito',
    seq_nd: 'Nota de D√©bito',
    seq_ret: 'Comprobante Retenci√≥n',
    seq_liq: 'Liquidaci√≥n Compra',
    seq_gr: 'Gu√≠a de Remisi√≥n',
  };
  const SEQ_FIELDS = Object.keys(DOC_BY_FIELD);

  // ------------------------------ helpers ------------------------------------
  const pad3 = v => (String(v ?? '').trim() || '0').padStart(3, '0');

  function firstChildFieldname(frm) {
    for (const f of TABLEFIELDS) if (frm.fields_dict[f]) return f;
    return null;
  }
  function getGrid(frm) {
    const f = firstChildFieldname(frm);
    return f ? frm.fields_dict[f]?.grid || null : null;
  }
  function getUninitializedCodes(frm) {
    const f = firstChildFieldname(frm);
    if (!f) return [];
    const rows = frm.doc[f] || [];
    return rows.filter(r => !Number(r.initiated || 0)).map(r => pad3(r.emission_point_code));
  }

  // ------------------------------ UI guards ----------------------------------
  function limit_establishment_input(frm) {
    // Limit parent 'custom_establishment_code' to 3 digits
    const f = frm.get_field('custom_establishment_code');
    if (!(f && f.$input)) return;

    f.$input.attr('maxlength', 3);
    f.$input.off('input.sri-est').on('input.sri-est', function () {
      this.value = this.value.replace(/\D/g, '').slice(0, 3);
    });
  }

  function limit_child_inputs(frm) {
    // Limit child 'emission_point_code' to 3 digits in the grid (rebounds after refresh)
    const grid = getGrid(frm);
    if (!(grid && grid.wrapper)) return;

    const $w = $(grid.wrapper);
    $w.find('input[data-fieldname="emission_point_code"]').attr('maxlength', 3);
    $w.off('input.sri-ep').on('input.sri-ep', 'input[data-fieldname="emission_point_code"]', function () {
      this.value = this.value.replace(/\D/g, '').slice(0, 3);
    });
  }

  function apply_tooltips(grid) {
    const $w = grid?.wrapper ? $(grid.wrapper) : null;
    if (!$w) return;
    $w.find('[data-fieldname="init_or_edit"] .btn').each(function () {
      this.setAttribute('aria-label', __('Init / Edit sequentials'));
      this.setAttribute('title', __('Init / Edit sequentials'));
    });
  }

  function lock_grid(frm) {
    const grid = getGrid(frm);
    if (!grid) return;

    // Make seq fields read-only & visible in list view
    grid.edit_form = false;
    SEQ_FIELDS.forEach(fn => {
      try { grid.update_docfield_property(fn, 'read_only', 1); } catch {}
      try { grid.update_docfield_property(fn, 'in_list_view', 1); } catch {}
    });
    ['emission_point_code', 'estado', 'initiated', 'init_or_edit'].forEach(fn => {
      try { grid.update_docfield_property(fn, 'in_list_view', 1); } catch {}
    });
    try { grid.update_docfield_property('init_or_edit', 'label', ''); } catch {}

    // Patch grid.refresh once to re-apply safeguards after every re-render
    if (!grid.__josfe_patched) {
      const original = grid.refresh;
      grid.refresh = function () {
        const out = original.apply(this, arguments);
        apply_tooltips(this);
        limit_child_inputs(frm);
        return out;
      };
      grid.__josfe_patched = true;
    }

    // First-time apply
    apply_tooltips(grid);
    limit_child_inputs(frm);
  }

  // ------------------------------ RPC ----------------------------------------
  async function callRPC(frm, row, updates, note, initiating) {
    return await frappe.call({
      method: "josfe.sri_invoicing.numbering.state.initiate_or_edit",
      args: {
        warehouse_name: frm.doc.name,
        row_name: row.name,                           // may be temp name; server resolves
        emission_point_code: row.emission_point_code, // server fallback key
        updates_dict: JSON.stringify(updates),
        note: note || ""
      },
      freeze: true,
      freeze_message: initiating ? __("Initiating‚Ä¶") : __("Applying‚Ä¶")
    });
  }

  // ------------------------------ Dialog UX ----------------------------------
  function clear_invalid(dlg) {
    SEQ_FIELDS.forEach(fn => {
      const f = dlg.fields_dict[fn];
      if (!f?.$wrapper) return;
      f.$wrapper.removeClass('josfe-invalid');
      f.$wrapper.find('.josfe-hint').remove();
    });
  }
  function hint_required(dlg, fn) {
    const f = dlg.fields_dict[fn];
    if (!f?.$wrapper) return;
    f.$wrapper.addClass('josfe-invalid');
    $('<div class="josfe-hint"></div>').text(__("Requerido (m√≠nimo 1)")).appendTo(f.$wrapper);
  }
  function hint_ge_saved(dlg, fn, prev) {
    const f = dlg.fields_dict[fn];
    if (!f?.$wrapper) return;
    f.$wrapper.addClass('josfe-invalid');
    $('<div class="josfe-hint"></div>').text(__("Debe ser ‚â• {0} (guardado)", [prev])).appendTo(f.$wrapper);
  }

  // ------------------------------ Child Button -------------------------------
  frappe.ui.form.on(CHILD, {
    // Button field in the child row
    init_or_edit(frm, cdt, cdn) {
      const row = frappe.get_doc(cdt, cdn);
      const initiating = !Boolean(row.initiated);

      const dlg = new frappe.ui.Dialog({
        title: initiating ? __('Iniciar secuenciales (todos ‚â• 1)') : __('Editar secuenciales (solo aumentos)'),
        fields: [
          { label: 'Factura',               fieldname: 'seq_factura', fieldtype: 'Int', default: row.seq_factura ?? 0 },
          { label: 'Nota de Cr√©dito',       fieldname: 'seq_nc',      fieldtype: 'Int', default: row.seq_nc ?? 0 },
          { label: 'Nota de D√©bito',        fieldname: 'seq_nd',      fieldtype: 'Int', default: row.seq_nd ?? 0 },
          { label: 'Comprobante Retenci√≥n', fieldname: 'seq_ret',     fieldtype: 'Int', default: row.seq_ret ?? 0 },
          { label: 'Liquidaci√≥n Compra',    fieldname: 'seq_liq',     fieldtype: 'Int', default: row.seq_liq ?? 0 },
          { label: 'Gu√≠a de Remisi√≥n',      fieldname: 'seq_gr',      fieldtype: 'Int', default: row.seq_gr ?? 0 },
          { label: 'Motivo / Nota',         fieldname: 'note',        fieldtype: 'Small Text' }
        ],
        primary_action_label: initiating ? __('Iniciar') : __('Aplicar'),

        async primary_action(values) {
          clear_invalid(dlg);

          const updates = {};
          let invalid = false;

          if (initiating) {
            // INIT: all six required and >= 1
            SEQ_FIELDS.forEach(fn => {
              const v = parseInt(values[fn], 10);
              if (Number.isNaN(v) || v < 1) { hint_required(dlg, fn); invalid = true; return; }
              updates[DOC_BY_FIELD[fn]] = v;
            });
            if (invalid) return;
          } else {
            // EDIT: equals ok, lower blocked, higher collected
            SEQ_FIELDS.forEach(fn => {
              const raw = values[fn];
              if (raw === '' || raw == null) return; // left untouched
              const v = parseInt(raw, 10);
              const prev = Number(row[fn] || 0);
              if (Number.isNaN(v) || v < prev) { hint_ge_saved(dlg, fn, prev); invalid = true; return; }
              if (v > prev) updates[DOC_BY_FIELD[fn]] = v;
            });
            if (invalid) return;
            if (!Object.keys(updates).length) { dlg.hide(); return; } // nothing to do
          }

          try {
            const res = await callRPC(frm, row, updates, values.note, initiating);
            if (res?.message?.status === "ok")
              frappe.show_alert({ message: __("{0} OK", [res.message.action]), indicator: "green" });
            dlg.hide(); frm.reload_doc();
          } catch (e) {
            const msg = e?._server_messages ? JSON.parse(e._server_messages).join("<br>") : (e?.message || String(e));
            frappe.show_alert({ message: msg, indicator: "red" });
          }
        }
      });

      // prevent negatives while typing
      dlg.$wrapper.on('input', 'input[data-fieldtype="Int"]', function (ev) {
        const v = ev.target.value;
        if (v && Number(v) < 0) ev.target.value = 0;
      });

      dlg.show();
    }
  });

  // ------------------------------ Warehouse events ---------------------------
  frappe.ui.form.on(WAREHOUSE, {
    onload_post_render(frm) {
      lock_grid(frm);
      limit_establishment_input(frm);
      limit_child_inputs(frm);
    },
    refresh(frm) {
      lock_grid(frm);
      limit_establishment_input(frm);
      limit_child_inputs(frm);
    },
    validate(frm) {
      const missing = getUninitializedCodes(frm);
      if (missing.length) {
        frappe.throw(
          __('Inicialice los Puntos de Emisi√≥n {0} desde el bot√≥n üîß. Todos los secuenciales deben ser ‚â• 1.', [missing.join(', ')])
        );
      }
    }
  });

  // If this file loads while already on a Warehouse form
  if (window.cur_frm?.doctype === WAREHOUSE) {
    lock_grid(cur_frm);
    limit_establishment_input(cur_frm);
    limit_child_inputs(cur_frm);
  }
})();
