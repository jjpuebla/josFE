// SRI Puntos Emisión — Warehouse client script (Frappe v15)
// -----------------------------------------------------------------------------
// Features:
// • INIT/EDIT dialog for the six sequentials with validation.
// • Blocks Save until every row is INIT'd (all six seq ≥ 1).
// • Server RPC resolves/creates rows by (Warehouse + emission_point_code).
// • Tooltips, read-only grid cols, prevents auto-save edits.
// • 3-digit guards for: establishment code (parent) and emission point (child).
//
// Notes:
// • No attempts to hide the inline "pencil" (row open icon) are included.
// • All event bindings are namespaced and idempotent to survive grid refreshes.
// -----------------------------------------------------------------------------

(() => {
  const CHILD = 'SRI Puntos Emision';
  const WAREHOUSE = 'Warehouse';
  
  // Put your exact child table fieldname first; others are fallbacks
  const TABLEFIELDS = [
    'custom_jos_SRI_puntos_emision',
    'custom_jos_Sri_puntos_emision',
    'custom_sri_puntos_emision'
  ];

  // Map child seq fields -> server doc-type labels (must match FIELD_BY_TYPE in state.py)
  const DOC_BY_FIELD = {
    seq_factura: 'Factura',
    seq_nc: 'Nota de Crédito',
    seq_nd: 'Nota de Débito',
    seq_ret: 'Comprobante Retención',
    seq_liq: 'Liquidación Compra',
    seq_gr: 'Guía de Remisión',
  };
  const SEQ_FIELDS = Object.keys(DOC_BY_FIELD);

  // ------------------------------ helpers ------------------------------------
  const pad3 = v => (String(v ?? '').trim() || '0').padStart(3, '0');

  function firstChildFieldname(frm) {
    for (const f of TABLEFIELDS) if (frm.fields_dict[f]) return f;
    return null;
  }
  function getGrid(frm) {
    const f = firstChildFieldname(frm);
    return f ? frm.fields_dict[f]?.grid || null : null;
  }
  function getUninitializedCodes(frm) {
    const f = firstChildFieldname(frm);
    if (!f) return [];
    const rows = frm.doc[f] || [];
    return rows.filter(r => !Number(r.initiated || 0)).map(r => pad3(r.emission_point_code));
  }

  // ------------------------------ UI guards ----------------------------------
  function limit_establishment_input(frm) {
    // Limit parent 'custom_establishment_code' to 3 digits
    const f = frm.get_field('custom_establishment_code');
    if (!(f && f.$input)) return;

    f.$input.attr('maxlength', 3);
    f.$input.off('input.sri-est').on('input.sri-est', function () {
      this.value = this.value.replace(/\D/g, '').slice(0, 3);
    });
  }

  function limit_child_inputs(frm) {
    // Limit child 'emission_point_code' to 3 digits in the grid (rebounds after refresh)
    const grid = getGrid(frm);
    if (!(grid && grid.wrapper)) return;

    const $w = $(grid.wrapper);
    $w.find('input[data-fieldname="emission_point_code"]').attr('maxlength', 3);
    $w.off('input.sri-ep').on('input.sri-ep', 'input[data-fieldname="emission_point_code"]', function () {
      this.value = this.value.replace(/\D/g, '').slice(0, 3);
    });
  }

  function apply_tooltips(grid) {
    const $w = grid?.wrapper ? $(grid.wrapper) : null;
    if (!$w) return;
    $w.find('[data-fieldname="init_or_edit"] .btn').each(function () {
      this.setAttribute('aria-label', __('Init / Edit sequentials'));
      this.setAttribute('title', __('Init / Edit sequentials'));
    });
  }

  function lock_grid(frm) {
    const grid = getGrid(frm);
    if (!grid) return;

    // Make seq fields read-only & visible in list view
    grid.edit_form = false;
    SEQ_FIELDS.forEach(fn => {
      try { grid.update_docfield_property(fn, 'read_only', 1); } catch {}
      try { grid.update_docfield_property(fn, 'in_list_view', 1); } catch {}
    });
    ['emission_point_code', 'estado', 'initiated', 'init_or_edit'].forEach(fn => {
      try { grid.update_docfield_property(fn, 'in_list_view', 1); } catch {}
      if (fn === 'initiated') {
        try { grid.update_docfield_property(fn, 'read_only', 1); } catch {}
      }
    });
    try { grid.update_docfield_property('init_or_edit', 'label', ''); } catch {}

    // Patch grid.refresh once to re-apply safeguards after every re-render
    if (!grid.__josfe_patched) {
      const original = grid.refresh;
      grid.refresh = function () {
        const out = original.apply(this, arguments);
        apply_tooltips(this);
        limit_child_inputs(frm);
        return out;
      };
      grid.__josfe_patched = true;
    }

    // First-time apply
    apply_tooltips(grid);
    limit_child_inputs(frm);

    // Intercept delete attempts and check server condition
    const $w = $(grid.wrapper);
    $w.off('click.josfe-no-del')
      .on('click.josfe-no-del',
        '.grid-remove-rows, .grid-delete, .grid-row .btn-remove, .grid-row .grid-delete-row',
async (e) => {
  e.preventDefault();
  e.stopImmediatePropagation();

  console.log("=== [josfe:delete-guard] DELETE CLICK DEBUG START ===");
  console.log("[josfe:delete-guard] e.currentTarget =", e.currentTarget);

  const $btn = $(e.currentTarget);

  let docsToCheck = [];

  if ($btn.hasClass("btn-remove")) {
    // Case 1: single-row trash button
    const gridRowObj = $btn.closest(".grid-row").data("grid_row");
    if (gridRowObj && gridRowObj.doc) {
      docsToCheck = [gridRowObj.doc];
      console.log("[josfe:delete-guard] Single row delete →", docsToCheck);
    }
  } else if ($btn.hasClass("grid-remove-rows")) {
    // Case 2: bulk delete
    const selected = grid.get_selected_children();
    docsToCheck = selected || [];
    console.log("[josfe:delete-guard] Bulk delete →", docsToCheck);
  }

  if (!docsToCheck.length) {
    console.error("[josfe:delete-guard] ❌ Could not resolve any PE docs to check.");
    frappe.msgprint(__('⚠️ Error interno: no se pudo resolver filas para eliminar.'));
    console.log("=== [josfe:delete-guard] DELETE CLICK DEBUG END ===");
    return false;
  }

  try {
    for (let doc of docsToCheck) {
      const res = await frappe.call({
        method: "josfe.sri_invoicing.utils.common.can_delete_pe",
        args: {
          warehouse_name: frm.doc.name,
          emission_point_code: doc.emission_point_code
        }
      });
      console.log("[josfe:delete-guard] Server responded:", doc.emission_point_code, res);

if (res.message === true) {
  console.log("[josfe:delete-guard] ✅ Allowed delete for PE", doc.emission_point_code);

  // Temporarily unbind guard → perform real delete
  $w.off('click.josfe-no-del');
  $(e.currentTarget).trigger('click');

  // ✅ After a short tick, save + reload parent
  frappe.dom.freeze(__("Eliminando Punto de Emisión…"));
  setTimeout(() => {
    frm.save().then(() => {
      return frm.reload_doc();
    }).then(() => {
      frappe.dom.unfreeze();
      frappe.show_alert({
        message: __("Punto de Emisión eliminado correctamente."),
        indicator: "green"
      });
    }).catch(err => {
      frappe.dom.unfreeze();
      console.error("[josfe:delete-guard] Error saving after delete:", err);
    });
  }, 300);

  return false;
}

    }

    // If all docs allowed → perform real delete
    console.log("[josfe:delete-guard] ✅ All PEs safe to delete, proceeding...");
    $w.off("click.josfe-no-del");
    $(e.currentTarget).trigger("click");
  } catch (err) {
    console.error("[josfe:delete-guard] Error verificando eliminación:", err);
    frappe.msgprint(__('Error verificando eliminación: ') + (err.message || err));
  }

  console.log("=== [josfe:delete-guard] DELETE CLICK DEBUG END ===");
  return false;
}

      );
  }

  // ------------------------------ RPC ----------------------------------------
  async function callRPC(frm, row, updates, note, initiatingNow) {
    return await frappe.call({
      method: "josfe.sri_invoicing.numbering.state.initiate_or_edit",
      args: {
        warehouse_name: frm.doc.name,
        // Only pass row_name when editing an existing initialized row
        row_name: initiatingNow ? null : row.name,
        emission_point_code: row.emission_point_code,
        establishment_code: (frm.doc.custom_establishment_code || "").trim(),
        updates_dict: JSON.stringify(updates),
        note: note || ""
      },
      freeze: true,
      freeze_message: initiatingNow ? __("Initiating…") : __("Applying…")
    });
  }

  // ------------------------------ Dialog UX ----------------------------------
  function clear_invalid(dlg) {
    SEQ_FIELDS.forEach(fn => {
      const f = dlg.fields_dict[fn];
      if (!f?.$wrapper) return;
      f.$wrapper.removeClass('josfe-invalid');
      f.$wrapper.find('.josfe-hint').remove();
    });
  }
  function hint_required(dlg, fn) {
    const f = dlg.fields_dict[fn];
    if (!f?.$wrapper) return;
    f.$wrapper.addClass('josfe-invalid');
    $('<div class="josfe-hint"></div>').text(__("Requerido (mínimo 1)")).appendTo(f.$wrapper);
  }
  function hint_ge_saved(dlg, fn, prev) {
    const f = dlg.fields_dict[fn];
    if (!f?.$wrapper) return;
    f.$wrapper.addClass('josfe-invalid');
    $('<div class="josfe-hint"></div>').text(__("Debe ser ≥ {0} (guardado)", [prev])).appendTo(f.$wrapper);
  }

  // ------------------------------ Child Button -------------------------------
  frappe.ui.form.on(CHILD, {
    // Button field in the child row
    init_or_edit(frm, cdt, cdn) {
      const row = frappe.get_doc(cdt, cdn);
      const initiating = !Boolean(row.initiated);

      const dlg = new frappe.ui.Dialog({
        title: initiating ? __('Iniciar secuenciales (todos ≥ 1)') : __('Editar secuenciales (solo aumentos)'),
        fields: [
          { label: 'Factura',               fieldname: 'seq_factura', fieldtype: 'Int', default: row.seq_factura ?? 0 },
          { label: 'Nota de Crédito',       fieldname: 'seq_nc',      fieldtype: 'Int', default: row.seq_nc ?? 0 },
          { label: 'Nota de Débito',        fieldname: 'seq_nd',      fieldtype: 'Int', default: row.seq_nd ?? 0 },
          { label: 'Comprobante Retención', fieldname: 'seq_ret',     fieldtype: 'Int', default: row.seq_ret ?? 0 },
          { label: 'Liquidación Compra',    fieldname: 'seq_liq',     fieldtype: 'Int', default: row.seq_liq ?? 0 },
          { label: 'Guía de Remisión',      fieldname: 'seq_gr',      fieldtype: 'Int', default: row.seq_gr ?? 0 },
          { label: 'Motivo / Nota',         fieldname: 'note',        fieldtype: 'Small Text' }
        ],
        primary_action_label: initiating ? __('Iniciar') : __('Aplicar'),

        async primary_action(values) {
          // robust mode detection based on the visible button label
          const __btn = (cur_dialog && cur_dialog.get_primary_btn && cur_dialog.get_primary_btn()) || null;
          const __btn_text = __btn && (typeof __btn.text === "function" ? __btn.text() : (__btn.html && __btn.html())) || "";
          const __looks_like_init = /iniciar/i.test(String(__btn_text || ""));
          const initiatingNow = __looks_like_init || initiating; // force INIT if the dialog shows "Iniciar"

          clear_invalid(dlg);

          // --- ensure Establishment Code exists on the SAVED doc & bypass validate guard ---
          const __code = (frm.doc.custom_establishment_code || "").trim();
          if (!__code || __code.length !== 3) {
            frappe.throw(__("Ingrese un Código de Establecimiento de 3 dígitos (001–999)."));
          }
          if (frm.is_dirty()) {
            window.__josfe_init_saving__ = true;
            frappe.dom.freeze(__("Guardando Establecimiento…"));
            try { await frm.save(); }
            finally { frappe.dom.unfreeze(); window.__josfe_init_saving__ = false; }
          }
          // -------------------------------------------------------------------------------

          const updates = {};
          let invalid = false;

          if (initiatingNow) {
            // INIT: all six required and ≥ 1
            SEQ_FIELDS.forEach(fn => {
              const v = parseInt(values[fn], 10);
              if (Number.isNaN(v) || v < 1) { hint_required(dlg, fn); invalid = true; return; }
              updates[DOC_BY_FIELD[fn]] = v;
            });
            if (invalid) return;
          } else {
            // EDIT: equals ok, lower blocked, higher collected
            SEQ_FIELDS.forEach(fn => {
              const raw = values[fn];
              if (raw === '' || raw == null) return; // left untouched
              const v = parseInt(raw, 10);
              const prev = Number(row[fn] || 0);
              if (Number.isNaN(v) || v < prev) { hint_ge_saved(dlg, fn, prev); invalid = true; return; }
              if (v > prev) updates[DOC_BY_FIELD[fn]] = v;
            });
            if (invalid) return;
            if (!Object.keys(updates).length) { dlg.hide(); return; } // nothing to do
          }

          try {
            frappe.dom.freeze(initiatingNow ? __("Iniciando…") : __("Aplicando…"));
            /* ************console.debug************/ 
            console.log("[josfe:init_or_edit] values from dialog:", values);
            console.log("[josfe:init_or_edit] updates dict to send:", updates);
            /* ************console.debug************/
            const res = await callRPC(frm, row, updates, values.note, initiatingNow);
            if (res?.message?.status === "ok")
              frappe.show_alert({ message: __("{0} OK", [res.message.action]), indicator: "green" });
            dlg.hide(); frm.reload_doc();
          } catch (e) {
            const msg = e?._server_messages ? JSON.parse(e._server_messages).join("<br>") : (e?.message || String(e));
            frappe.show_alert({ message: msg, indicator: "red" });
          } finally {
            frappe.dom.unfreeze();
          }
        }
      });

      // prevent negatives while typing
      dlg.$wrapper.on('input', 'input[data-fieldtype="Int"]', function (ev) {
        const v = ev.target.value;
        if (v && Number(v) < 0) ev.target.value = 0;
      });

      dlg.show();
    }
  });

// ------------------------------ Estado toggle rule -------------------------------
  frappe.ui.form.on(CHILD, {
      estado: function (frm, cdt, cdn) {
          const row = frappe.get_doc(cdt, cdn);

          if (row.estado === "Activo") {
              // Ensure all other rows become Inactivo
              (frm.doc.custom_sri_puntos_emision || []).forEach(r => {
                  if (r.name !== row.name && r.estado === "Activo") {
                      r.estado = "Inactivo";
                  }
              });

              // Refresh child grid
              frm.refresh_field("custom_sri_puntos_emision");

              // ✅ Save + reload parent Warehouse
              frappe.dom.freeze(__("Guardando cambios…"));
              frm.save()
                  .then(() => frm.reload_doc())
                  .then(() => {
                      frappe.dom.unfreeze();
                      frappe.show_alert({
                          message: __("Se estableció Punto de Emisión activo."),
                          indicator: "green"
                      });
                  })
                  .catch(err => {
                      frappe.dom.unfreeze();
                      console.error("[josfe:estado] Error al guardar:", err);
                      frappe.msgprint(__('Error al guardar el cambio de Activo: ') + (err.message || err));
                  });
          }
      }
  });



  // ------------------------------ Warehouse events ---------------------------
  frappe.ui.form.on(WAREHOUSE, {
    onload_post_render(frm) {
      lock_grid(frm);
      limit_establishment_input(frm);
      limit_child_inputs(frm);
    },
    refresh(frm) {
      lock_grid(frm);
      limit_establishment_input(frm);
      limit_child_inputs(frm);
    },
    validate(frm) {
      // Skip ONLY while auto-saving for INIT to avoid the known race
      if (window.__josfe_init_saving__) { return; }
      const missing = getUninitializedCodes(frm);
      if (missing.length) {
        frappe.throw(
          __('Inicialice los Puntos de Emisión {0} desde el botón 🔧. Todos los secuenciales deben ser ≥ 1.', [missing.join(', ')])
        );
      }
    }
  });

  // If this file loads while already on a Warehouse form
  if (window.cur_frm?.doctype === WAREHOUSE) {
    lock_grid(cur_frm);
    limit_establishment_input(cur_frm);
    limit_child_inputs(cur_frm);
  }

  // ========================= SRI Establishment UI & Inheritance =========================
  (function () {
    const WAREHOUSE = 'Warehouse';
    const FLD_IS_EST = 'custom_sri_is_establishment';
    const FLD_EST_CODE = 'custom_establishment_code';
    const GRID_PTO = (function findChildFieldname() {
      // Reuse the same child fieldname resolution logic from this file
      // (TABLEFIELDS is already defined at top of the file)
      for (const f of (typeof TABLEFIELDS !== 'undefined' ? TABLEFIELDS : [GRID_PTO])) {
        if (cur_frm?.fields_dict?.[f]) return f;
      }
      // fallback to most common fieldname if not on a form yet
      return 'custom_sri_puntos_emision';
    })();
    // The section that contains both Establishment Code + Puntos de Emisión grid
    const SEC_BREAK = 'custom_section_break_04hqx';

    function getGrid2(frm) {
      const f = (typeof firstChildFieldname === 'function') ? firstChildFieldname(frm) : GRID_PTO;
      return f && frm.fields_dict[f] ? frm.fields_dict[f].grid : null;
    }

    async function ancestor_has_establishment(parentName) {
      const FLD = FLD_IS_EST;
      let current = parentName;
      let guard = 0;
      while (current && guard < 25) {
        guard += 1;
        const res = await frappe.db.get_value('Warehouse', current, ['parent_warehouse', FLD]);
        const msg = res && res.message ? res.message : {};
        if (msg[FLD]) return true;
        current = msg.parent_warehouse || null;
      }
      return false;
    }

    function apply_est_section_visibility(frm, on) {
      // Show/hide the *section* that contains both code + grid
      if (frm.fields_dict[SEC_BREAK]) frm.toggle_display(SEC_BREAK, on);

      // Keep direct toggles as well (safe even if section is hidden by layout)
      frm.toggle_display(FLD_EST_CODE, on);
      frm.toggle_display(GRID_PTO, on);

      // When turning OFF, clear code and remove grid rows
      if (!on) {
        if (frm.doc[FLD_EST_CODE]) frm.set_value(FLD_EST_CODE, '');
        const grid = getGrid2(frm);
        if (Array.isArray(frm.doc[GRID_PTO]) && frm.doc[GRID_PTO].length) {
          // Use the official helper to clear a child table
          frm.clear_table(GRID_PTO);
          frm.refresh_field(GRID_PTO);
        }
      }
    }

    async function apply_establishment_inheritance_rules(frm) {
      const hasAncestorEst = await ancestor_has_establishment(frm.doc.parent_warehouse);

      if (hasAncestorEst) {
        if (frm.doc[FLD_IS_EST]) await frm.set_value(FLD_IS_EST, 0);

        // Hide the checkbox completely
        if (frm.fields_dict[FLD_IS_EST]) {
          frm.toggle_display(FLD_IS_EST, false);
          frm.set_df_property(FLD_IS_EST, 'read_only', 1);
        }

        // Hide the section & its internals
        apply_est_section_visibility(frm, false);

        // Also lock underlying fields/grid
        if (frm.fields_dict[FLD_EST_CODE]) frm.set_df_property(FLD_EST_CODE, 'read_only', 1);
        if (frm.fields_dict[GRID_PTO])  frm.set_df_property(GRID_PTO,  'read_only', 1);
      } else {
        if (frm.fields_dict[FLD_IS_EST]) {
          frm.toggle_display(FLD_IS_EST, true);
          frm.set_df_property(FLD_IS_EST, 'read_only', 0);
        }
        if (frm.fields_dict[FLD_EST_CODE]) frm.set_df_property(FLD_EST_CODE, 'read_only', 0);
        if (frm.fields_dict[GRID_PTO])  frm.set_df_property(GRID_PTO,  'read_only', 0);

        // Respect current checkbox value for section visibility
        apply_est_section_visibility(frm, !!frm.doc[FLD_IS_EST]);
      }
    }

    function bind_establishment_handlers() {
      frappe.ui.form.on(WAREHOUSE, {
        async refresh(frm) {
          if (typeof lock_grid === 'function') lock_grid(frm);
          if (typeof limit_establishment_input === 'function') limit_establishment_input(frm);
          if (typeof limit_child_inputs === 'function') limit_child_inputs(frm);
          await apply_establishment_inheritance_rules(frm);
        },
        async onload_post_render(frm) {
          if (typeof lock_grid === 'function') lock_grid(frm);
          if (typeof limit_establishment_input === 'function') limit_establishment_input(frm);
          if (typeof limit_child_inputs === 'function') limit_child_inputs(frm);
          await apply_establishment_inheritance_rules(frm);
        },
        async parent_warehouse(frm) {
          await apply_establishment_inheritance_rules(frm);
        }
      });

      // Live toggle: when user clicks the checkbox
      const ev = {};
      ev[FLD_IS_EST] = async function (frm) {
        const blocked = await ancestor_has_establishment(frm.doc.parent_warehouse);
        if (blocked) return;
        apply_est_section_visibility(frm, !!frm.doc[FLD_IS_EST]);
        if (frm.doc[FLD_IS_EST]) {
          if (typeof lock_grid === 'function') lock_grid(frm);
          if (typeof limit_establishment_input === 'function') limit_establishment_input(frm);
          if (typeof limit_child_inputs === 'function') limit_child_inputs(frm);
        }
      };
      frappe.ui.form.on(WAREHOUSE, ev);
    }

    if (!window.__josfe_wh_establishment_bound__) {
      bind_establishment_handlers();
      window.__josfe_wh_establishment_bound__ = true;
    }

    // If this file loaded while a Warehouse form is already open, apply now
    if (window.cur_frm?.doctype === WAREHOUSE) {
      (async () => { await apply_establishment_inheritance_rules(cur_frm); })();
    }
  })();

})();
